---
meta:
  - name: description
    content: Documentation over JsonMapper and decorators provided by Ts.ED framework. Use decorator to build your model and map data.
  - name: keywords
    content: class model decorators ts.ed express typescript node.js javascript jsonschema json mapper serialization deserialization
---

# JsonMapper

The `@tsed/json-mapper` package is responsible to map a plain object to a model and a model to a plain object.

It provides two functions @@serialize@@ and @@deserialize@@ to transform object depending on which operation you want to perform.
It uses all decorators from `@tsed/schema` package and TypeScript metadata to work.

Ts.ED use this package to transform any input parameters sent by your consumer to a class and transform returned value by your endpoint
to a plain javascript object to your consumer.

::: warning Breaking change
For v5 developer, `@tsed/json-mapper` package is the new API under the @@ConverterService@@. There are some breaking changes between the previous service implementation:

- The `@Converter` decorator have been removed in favor of @@JsonMapper@@ decorator.
- Classes like `ArrayConverter`, `SetConverter`, etc... replaced by his equivalents Types mapper: @@ArrayMapper@@, @@SetMapper@@, etc...
- Type mapper classes are no longer injectable services.
- ConverterService is always available and can be injected to another provider, but now, ConverterService doesn't perform data validation. Validation is performed by [`@tsed/ajv`](/tutorials/ajv.md) package or any other validation library.
- `PropertyDeserialize` and `PropertySerialize` have been removed and replaced by @@OnDeserialize@@ and @@OnSerialize@@.
- Methods Signatures of Type mapper (like ArrayConverter) have changed.
  :::

## Usage

JsonMapper works with a class and decorators. Use decorators on properties to describe a model and use this model as an input parameter or return value by your endpoint. Here is a model example:

<Tabs class="-code">
  <Tab label="Person.ts">

<<< @/docs/snippets/converters/model-usage.ts

  </Tab>
  <Tab label="Jest">
  
<<< @/docs/snippets/converters/model-usage.jest.ts
  
  </Tab>
  <Tab label="Mocha">

<<< @/docs/snippets/converters/model-usage.mocha.ts

  </Tab>
</Tabs>

::: tip Note
Take a look on Jest/Mocha tabs to see @@serialize@@ and @@deserialize@@ functions usage.
:::

Now we can use the `Person` model on a controller:

<<< @/docs/snippets/converters/controller-usage.ts

::: tip Note
In the previous example, we can see @@Returns@@ decorator usage.
In all case, Ts.ED infer the returned value and apply the correct transformation on your response.

@@Returns@@ decorator is used to generate the correct swagger documentation only.
:::

::: warning
When a model is provided, JsonMapper will follow exactly the JsonSchema generated by `@tsed/schema` package.

It means, if you missed decorating one or more properties on your model, these properties won't be appear after the transformation.

<Tabs class="-code">
  <Tab label="User.ts">

<<< @/docs/snippets/converters/model-missing-properties.ts
</Tab>
<Tab label="Jest">

<<< @/docs/snippets/converters/model-missing-properties.jest.ts

  </Tab>
  <Tab label="Mocha">

<<< @/docs/snippets/converters/model-missing-properties.mocha.ts

  </Tab>
</Tabs>

> Note: Result is displayed in Jest/Mocha tabs.

:::

## Ignore properties

### Usage

@@Ignore@@ decorator can be used to ignore explicitly a property when a transformation have been performed.

For example, you have a base model to create a User named `UserCreation` where the `password` is required, but
you don't want to expose this field in other cases. One of the solution is to use class inheritance to solve this problem.

<Tabs class="-code">
  <Tab label="User.ts">

<<< @/docs/snippets/converters/model-ignore-props.ts

  </Tab>
  <Tab label="Jest">
  
<<< @/docs/snippets/converters/model-ignore-props.jest.ts
  
  </Tab>
  <Tab label="Mocha">

<<< @/docs/snippets/converters/model-ignore-props.mocha.ts

  </Tab>
</Tabs>

### With a callback

@@Ignore@@ decorator since v6.13.0 accept a callback which will be called when a property have been serialized or deserialized.
The callback will give you more control over the way to ignore a property.

```typescript
class User {
  @Name("id")
  _id: string;

  @Property()
  firstName: string;

  @Property()
  lastName: string;

  @Ignore((value, ctx) => ctx.endpoint) // should not serialized when the object is returned by an endpoint.
  password: string;

  @Ignore((value, ctx) => ctx.mongoose) // should be serialized when the object is returned by an endpoint.
  scopes: string[];

  @Ignore()
  alwaysIgnored: string;
}
```

Here is the available options on ctx:

| Prop     | Type    | Description              |
| -------- | ------- | ------------------------ |
| endpoint | boolean | It's an endpoint context |
| mongoose | boolean | It's a mongoose context  |

## Additional properties

@@AdditionalProperties@@ decorator can be used to accept any additional properties on a specific model.

<Tabs class="-code">
  <Tab label="Person.ts">

<<< @/docs/snippets/converters/model-additional-props.ts

  </Tab>
  <Tab label="Jest">
  
<<< @/docs/snippets/converters/model-additional-props.jest.ts
  
  </Tab>
  <Tab label="Mocha">

<<< @/docs/snippets/converters/model-additional-props.mocha.ts

  </Tab>
</Tabs>

## Alias

@@Name@@ decorator lets you to rename the exposed property in your json schema.

For example mongo db uses the `_id` property.
In order not to give any indication to our consumer about the nature of the database, it's better to rename the property to `id`.

<<< @/docs/snippets/model/name.ts

## OnSerialize

@@OnSerialize@@ decorator can be used to intercept and change the property value when a serialization is performed on class.

```typescript
import {OnSerialize} from "@tsed/schema";

export class Person {
  @OnSerialize((v) => v + "Test")
  property: string;
}
```

## OnDeserialize

@@OnDeserialize@@ decorator can be used to intercept and change the property value when a deserialization is performed on class.

```typescript
import {OnDeserialize} from "@tsed/schema";

export class Person {
  @OnDeserialize((v) => v + "Test")
  property: string;
}
```

## Type mapper

`@tsed/json-mapper` use classes to transform an input value to the expected value:

| Type        | Mapper                                             |
| ----------- | -------------------------------------------------- |
| Primitives  | @@PrimitiveMapper@@,                               |
| Symbol      | @@SymbolMapper@@,                                  |
| Objects     | @@DateMapper@@,                                    |
| Collections | Â @@ArrayMapper@@, @@MapMapper@@ and @@SetMapper@@. |

It's possible to add your own type mapper by using the @@JsonMapper@@ decorator on a class. Just copy a mapper implementation
and import the mapper in your application.

### Primitives

@@PrimitiveMapper@@ is responsible to map the primitive value like `Boolean`, `Number` or `String`.

<Tabs class="-code">
  <Tab label="PrimitiveMapper">
  
<<< @/../packages/specs/json-mapper/src/components/PrimitiveMapper.ts
  
  </Tab>

  <Tab label="Spec">
 
<<< @/../packages/specs/json-mapper/src/components/PrimitiveMapper.spec.ts
  
  </Tab>
</Tabs>

#### Cheat sheet

| Input       | Type    | Output                                                                             |
| ----------- | ------- | ---------------------------------------------------------------------------------- |
| `1`         | String  | `"1"`                                                                              |
| `"1"`       | String  | `"1"`                                                                              |
| `null`      | Number  | `null`                                                                             |
| `"null"`    | Number  | `null`                                                                             |
| `"1"`       | Number  | `1`                                                                                |
| `1`         | Number  | `1`                                                                                |
| `"to1"`     | Number  | Throw Bad Request. This is the only case where JsonMapper throw a cast type error. |
| `true`      | Boolean | `true`                                                                             |
| `"true"`    | Boolean | `true`                                                                             |
| `"1"`       | Boolean | `true`                                                                             |
| `1`         | Boolean | `true`                                                                             |
| `false`     | Boolean | `false`                                                                            |
| `"false"`   | Boolean | `false`                                                                            |
| `"0"`       | Boolean | `false`                                                                            |
| `0`         | Boolean | `false`                                                                            |
| `""`        | Boolean | `false`                                                                            |
| `"null"`    | Boolean | `null`                                                                             |
| `undefined` | Boolean | `undefined`                                                                        |

### Symbol

@@SymbolMapper@@ is responsible to map a `String` to `Symbol` or a `Symbol` to a `String`.

<Tabs class="-code">
  <Tab label="SymbolMapper">
  
<<< @/../packages/specs/json-mapper/src/components/SymbolMapper.ts

  </Tab>
  <Tab label="Spec">
 
<<< @/../packages/specs/json-mapper/src/components/SymbolMapper.spec.ts
  
  </Tab>
</Tabs>

### Date

@@DateMapper@@ is responsible to map a `Number`, `String` to a `Date` or a `Date` to a `String`.

<Tabs class="-code">
  <Tab label="DateMapper">
  
<<< @/../packages/specs/json-mapper/src/components/DateMapper.ts

  </Tab>
  <Tab label="Spec">
 
<<< @/../packages/specs/json-mapper/src/components/DateMapper.spec.ts
  
  </Tab>
</Tabs>

### Array

@@ArrayMapper@@ is responsible to map any data to an `Array`.

<Tabs class="-code">
  <Tab label="ArrayMapper">
  
<<< @/../packages/specs/json-mapper/src/components/ArrayMapper.ts

  </Tab>
  <Tab label="Spec">
 
<<< @/../packages/specs/json-mapper/src/components/ArrayMapper.spec.ts
  
  </Tab>
</Tabs>

### Map

@@MapMapper@@ is responsible to map an `Object` to a `Map`.

<Tabs class="-code">
  <Tab label="SetMapper">
  
<<< @/../packages/specs/json-mapper/src/components/MapMapper.ts

  </Tab>
  <Tab label="Example">
  
```typescript
import {CollectionOf} from "@tsed/schema";
import {Skill} from "./Skill";
 
export class Person {
  @CollectionOf(Skill)
  skills: Map<string, Skill>;
}
```
  
  </Tab>
  <Tab label="Spec">
 
<<< @/../packages/specs/json-mapper/src/components/MapMapper.spec.ts
  
  </Tab>
</Tabs>

### Set

@@SetMapper@@ is responsible to map an `Array` to a `Set`.

<Tabs class="-code">
  <Tab label="SetMapper">
  
<<< @/../packages/specs/json-mapper/src/components/SetMapper.ts

  </Tab>
  <Tab label="Example">
  
```typescript
import {CollectionOf} from "@tsed/schema";
 
export class Person {
  @CollectionOf(String)
  skills: Set<string>;
}
```
  
  </Tab>
  <Tab label="Spec">
 
<<< @/../packages/specs/json-mapper/src/components/SetMapper.spec.ts
  
  </Tab>
</Tabs>

## Create your own type mapper

It's possible de to change add your own type mapper by using the @@JsonMapper@@ decorator on a class. Just copy a mapper implementation
and import the mapper in your application.

A mapper must declare the type it must work on and implement two methods: serialize and deserialize.

```typescript
import {JsonMapper, JsonMapperMethods, JsonMapperCtx} from "@tsed/json-mapper";

@JsonMapper(String)
export class TheTypeMapper implements JsonMapperMethods {
  deserialize(data: any, ctx: JsonMapperCtx): String {
    return JSON.stringify(data) + ":deserialize";
  }

  serialize(data: any, ctx: JsonMapperCtx): String {
    return JSON.stringify(data) + ":serialize";
  }
}
```

Then import your new mapper in your Server.ts

### Moment

[Moment.js](https://momentjs.com) is a powerful library to transform any formatted date string to a Moment instance.

You can change the Date converter behavior to transform string to a Moment instance.

<Tabs class="-code">
  <Tab label="MomentMapper">
  
<<< @/docs/snippets/converters/moment-mapper.ts

  </Tab>
  <Tab label="Configuration">

<<< @/docs/snippets/converters/server-moment-mapper-import.ts

  </Tab>
  <Tab label="Example">
  
```typescript
import {Moment} from "moment";
import {Property} from "@tsed/schema";

export class Person {
@Property(Date) // or @Property(String) + @DateTime()
birthdate: Moment;
}

```

  </Tab>
</Tabs>
```
