---
meta:
  - name: description
    content: Documentation over Models and decorators provided by Ts.ED framework. Use decorator to build your model and JsonSchema.
  - name: keywords
    content: class model decorators ts.ed express typescript node.js javascript jsonschema
---

# Model

The classes can be used as a model in your application. Ts.ED uses these models to convert JSON objects to their class
equivalents.

The classes models can be used in the following cases:

- Data serialization and deserialization with the ([Json mapper](/docs/json-mapper.md)),
- Data validation with [AJV](/tutorials/ajv.md) or any library compatible with [JsonSchema](https://json-schema.org/),
- Generating documentation with [Swagger](/tutorials/swagger.md).

To create a model, Ts.ED provides decorators which will store and generate a
standard [JsonSchema](http://json-schema.org/) model.

::: warning
Validation is only available when you import `@tsed/ajv` package in your server.

```typescript
import {Configuration} from "@tsed/common";
import "@tsed/ajv";

@Configuration()
class Server {}
```

Without this package, decorators like @@Email@@ won't have any effect.
:::

## Example

The example below uses decorators to describe a property of the class and store metadata such as the description of the
field.

<<< @/docs/snippets/model/example.ts

::: tip
The Model will generate a JsonSchema which can be used by modules supporting JsonSchema spec
:::

::: warning
The schema generated by Ts.ED lists only properties decorated by at least one decorator. In the previous
example, the `_id` won't be displayed in the JsonSchema. It's very important to understand that **TypeScript** only
generates metadata on properties with at least one of these decorators:

<ApiList query="status.includes('decorator') && status.includes('schema') && status.includes('input')" />

:::

Our model is now described, we can use it inside a @@Controller@@ as input type parameter for our methods. Ts.ED will
use the model to convert the raw data to an instance of your model.

<<< @/docs/snippets/model/controller.ts

## Primitives

Just use at least @@Property@@ decorator any other `schema` decorator (like @@Email@@), to create a new property on a
model. Ts.ED will get the type from Typescript metadata and transform this type to a valid Json type.

<Tabs class="-code">
  <Tab label="Model">

<<< @/docs/snippets/model/primitives.ts

  </Tab>
  <Tab label="Json schema">

<<< @/docs/snippets/model/primitives.json

  </Tab>
</Tabs>

## Integer

The @@Integer@@ decorator is used to set integer type for integral numbers.

<Tabs class="-code">
  <Tab label="Model">

<<< @/docs/snippets/model/integer.ts

  </Tab>
  <Tab label="Json schema">

<<< @/docs/snippets/model/integer.json

  </Tab>
</Tabs>

## Any types

The @@Any@@, decorator is used to set one or more types on property. Use this method when you want to set explicitly the
json type or when you use a mixed TypeScript types.

<Tabs class="-code">
  <Tab label="Model">

<<< @/docs/snippets/model/any-types.ts

  </Tab>
  <Tab label="Json schema">

<<< @/docs/snippets/model/any-types.json

  </Tab>
</Tabs>

## Nullable

The @@Nullable@@ decorator is used allow a null value on a field while preserving the original Typescript type.

<Tabs class="-code">
  <Tab label="Model">

<<< @/docs/snippets/model/nullable-properties.ts

  </Tab>
  <Tab label="Json schema">

<<< @/docs/snippets/model/nullable-properties.json

  </Tab>
</Tabs>

## Any

The @@Any@@ decorator is used to allow any types:

<Tabs class="-code">
  <Tab label="Model">

```typescript
import {Any} from "@tsed/schema";

export class Model {
  @Any()
  prop: any;
}
```

  </Tab>
  <Tab label="Json schema">

```json
{
  "properties": {
    "prop": {
      "type": ["integer", "number", "string", "boolean", "array", "object", "null"]
    }
  },
  "type": "object"
}
```

  </Tab>
  <Tab label="OS3">

```json
{
  "properties": {
    "prop": {
      "nullable": true,
      "oneOf": [
        {
          "type": "integer"
        },
        {
          "type": "number"
        },
        {
          "type": "string"
        },
        {
          "type": "boolean"
        },
        {
          "type": "array"
        },
        {
          "type": "object"
        }
      ]
    }
  },
  "type": "object"
}
```

  </Tab>
</Tabs>

## Regular expressions

The @@Pattern@@ decorator is used to restrict a string to a particular regular expression. The regular expression syntax
is the one defined in JavaScript ([ECMA 262](https://www.ecma-international.org/publications/standards/Ecma-262.htm)
specifically).
See [Regular Expressions](https://json-schema.org/understanding-json-schema/reference/regular_expressions.html#regular-expressions)
for more information.

<Tabs class="-code">
  <Tab label="Model">

<<< @/docs/snippets/model/pattern.ts

  </Tab>
  <Tab label="Json schema">

<<< @/docs/snippets/model/pattern.json

  </Tab>
</Tabs>

## Format

The @@Format@@ decorator allows basic semantic validation on certain kinds of string values that are commonly used. This
allows values to be constrained beyond what the other tools in JSON Schema,
including [Regular Expressions](https://json-schema.org/understanding-json-schema/reference/regular_expressions.html#regular-expressions)
can do.

<Tabs class="-code">
  <Tab label="Model">

<<< @/docs/snippets/model/format.ts

  </Tab>
  <Tab label="Json schema">

<<< @/docs/snippets/model/format.json

  </Tab>
</Tabs>

The following formats are supported for string validation with `format` keyword by [AJV](https://ajv.js.org/):

- **date**: full-date according to [RFC3339](https://json-schema.org/latest/json-schema-validation.html#RFC3339).
- **time**: time with optional time-zone.
- **date-time**: date-time from the same source (time-zone is mandatory).
- **uri**: full uri with optional protocol.
- **email**: email address.
- **hostname**: host name according to [RFC1034](https://tools.ietf.org/html/rfc1034#section-3.1).
- **ipv4**: IP address v4.
- **ipv6**: IP address v6.
- **regex**: tests whether a string is a valid regular expression by passing it to RegExp constructor.

See built-in formats types
on [Jsonp-schema.org](https://json-schema.org/understanding-json-schema/reference/string.html#built-in-formats) for more
details:

## MultipleOf

Numbers can be restricted to a multiple of a given number, using the @@MultipleOf@@ decorator. It may be set to any
positive number.
See [json-schema documentation](https://json-schema.org/understanding-json-schema/reference/numeric.html#multiples) for
more details.

<Tabs class="-code">
  <Tab label="Model">

<<< @/docs/snippets/model/multiple-of.ts

  </Tab>
  <Tab label="Json schema">

<<< @/docs/snippets/model/multiple-of.json

  </Tab>
</Tabs>

## Ranges

Ranges of numbers are specified using a combination of the @@Minimum@@ and @@Maximum@@ decorators, (or
@@ExclusiveMinimum@@ and @@ExclusiveMaximum@@ for expressing exclusive range).
See [json-schema documentation](https://json-schema.org/understanding-json-schema/reference/numeric.html#multiples) for
more details.

<Tabs class="-code">
  <Tab label="Model">

<<< @/docs/snippets/model/ranges.ts

  </Tab>
  <Tab label="Json schema">

<<< @/docs/snippets/model/ranges.json

  </Tab>
</Tabs>

## Enumerated values

The @@Enum@@ decorator is used to restrict a value to a fixed set of values. It must be an array with at least one
element, where each element is unique or a TypeScript enum.

<Tabs class="-code">
  <Tab label="Model">

<<< @/docs/snippets/model/enumerated-values.ts

  </Tab>
  <Tab label="Json schema">

<<< @/docs/snippets/model/enumerated-values.json

  </Tab>
</Tabs>

@@Enum@@ decorator can be also in combination with @@BodyParams@@ or @QueryParams@@:

```typescript
import {Enum} from "@tsed/schema";
import {QueryParams, Controller} from "@tsed/common";

@Controller("/")
class MyController {
  @Post("/")
  async method(@QueryParams("type") @Enum(MyEnum) type: MyEnum): Promise<any> {
    return null;
  }
}
```

### Set label to an enum <Badge text="7.17.0+"/>

With OpenSpec 3 it's now possible to create shared enum for many models in `components.schemas` instead of having its inlined values in
each model.

Ts.ED introduce a new function `enums()` to declare the enum schema as follows:

```ts
import {enums} from "@tsed/schema";

enum ProductTypes {
  ALL = "ALL",
  ASSETS = "ASSETS",
  FOOD = "FOOD"
}

enums(ProductTypes).label("ProductTypes");

// in models
class Product {
  @Property()
  title: string;

  @Enum(ProductTypes)
  type: ProductTypes;
}

// in controller

import {Enum} from "@tsed/schema";
import {QueryParams, Controller} from "@tsed/common";

@Controller("/products")
class ProductsController {
  @Get("/:type")
  @Returns(200, Array).Of(Product)
  async get(@PathParams("type") @Enum(ProductTypes) type: ProductTypes): Promise<Product> {
    return [new Product()];
  }
}
```

## Constant values

The @@Const@@ decorator is used to restrict a value to a single value. For example, if you only support shipping to the
United States for export reasons:

<Tabs class="-code">
  <Tab label="Model">

<<< @/docs/snippets/model/constant-values.ts

  </Tab>
  <Tab label="Json schema">

<<< @/docs/snippets/model/constant-values.json

  </Tab>
</Tabs>

## Collections

Declaring a property that uses a collection is a bit different than declaring a simple property. TypeScript stores only
the `Array`/`Set`/`Map` type when you declare the type of your property. The type used by the collection is lost.

To tell Ts.ED (and other third party which uses JsonSchema) that a property uses a collection with a specific type, you
must use @@CollectionOf@@ (before v5.62.0, use @@PropertyType@@) decorator as following:

<Tabs class="-code">
  <Tab label="Model">

<<< @/docs/snippets/model/collections.ts

  </Tab>
  <Tab label="Json schema">

<<< @/docs/snippets/model/collections.json

  </Tab>
</Tabs>

Ts.ED provides others related collection decorators:

<ApiList query="status.includes('decorator') && status.includes('schema') && status.includes('collections')" />

## Required properties

By default, the properties defined with a decorator are not `required`. However, one can use @@Required@@ decorator to
add a required property to the json schema:

```typescript
import {Required} from "@tsed/schema";

class MyModel {
  id: string;

  @Required()
  prop1: string;
}
```

You can also add a custom ajv error message with the `.Error(msg)` function:

```typescript
import {Required} from "@tsed/schema";

class MyModel {
  id: string;

  @Required().Error("custom message")
  prop1: string;
}
```

## Custom AJV error messages

If you don't like AJV's default error messages, you can customize them with these decorators:

### DefaultMsg

This is a class decorator @@DefaultMsg@@ that is used to define a default message as the name suggests:

```typescript
import {DefaultMsg} from "@tsed/schema";

@DefaultMsg("an error occured")
class MyModel {
  id: string;

  prop1: string;
}
```

### TypeError

This is a property decorator @@TypeError@@ that is used to define a custom error message for a specific type:

```typescript
import {TypeError} from "@tsed/schema";

class MyModel {
  id: string;

  @TypeError("prop1 should be a string")
  prop1: string;
}
```

### ErrorMsg

If none of the above work for you, you can use the @@ErrorMsg@@ decorator to define your own custom error message schema using the [ajv-errors documentation](https://ajv.js.org/packages/ajv-errors.html#ajv-errors):

```typescript
import {ErrorMsg} from "@tsed/schema";

class MyModel {
  id: string;

  @ErrorMsg({type: "prop1 should be a string"})
  prop1: string;
}
```

## Additional properties

Sometimes, it can be useful to create model with additional properties. By default, Json schema is strict over extra
properties not declared in a model (
see [Properties json schema documentation](https://json-schema.org/understanding-json-schema/reference/object.html#properties)).

Use @@AdditionalProperties@@ on your model to allow this behavior:

<Tabs class="-code">
  <Tab label="Model">

<<< @/docs/snippets/model/additional-properties.ts

  </Tab>
  <Tab label="Json schema">

<<< @/docs/snippets/model/additional-properties.json

  </Tab>
</Tabs>

It is also possible to add contraint on additional properties, by giving a raw Json schema:

<Tabs class="-code">
  <Tab label="Model">

<<< @/docs/snippets/model/additional-properties-with-schema.ts

  </Tab>
  <Tab label="Json schema">

<<< @/docs/snippets/model/additional-properties-with-schema.json

  </Tab>
</Tabs>

Or by using @@getJsonSchema@@ in combination with @@AdditionalProperty@@ as following:

<Tabs class="-code">
  <Tab label="Model">

<<< @/docs/snippets/model/additional-properties-with-model.ts

  </Tab>
  <Tab label="Json schema">

<<< @/docs/snippets/model/additional-properties-with-model.json

  </Tab>
</Tabs>

## Circular ref

Circular reference can be resolved by using arrow with a @@Property@@ and @@CollectionOf@@ decorators:

<<< @/docs/snippets/model/circular-references.ts

## Custom Keys

Ts.ED introduces the @@Keyword@@ decorator to declare a new custom validator for Ajv. Combined with the @@CustomKey@@
decorator to add keywords to a property of your class, you can use more complex scenarios than what basic JsonSchema
allows.

For example, we can create a custom validator to support the `range` validation over a number. To do that, we have to
define the custom validator by using @@Keyword@@ decorator:

```typescript
import {Keyword, KeywordMethods} from "@tsed/ajv";
import {array, number} from "@tsed/schema";

@Keyword({
  keyword: "range",
  type: "number",
  schemaType: "array",
  implements: ["exclusiveRange"],
  metaSchema: array().items([number(), number()]).minItems(2).additionalItems(false)
})
class RangeKeyword implements KeywordMethods {
  compile([min, max]: number[], parentSchema: any) {
    return parentSchema.exclusiveRange === true ? (data: any) => data > min && data < max : (data: any) => data >= min && data <= max;
  }
}
```

Then we can declare a model using the standard decorators from `@tsed/schema`:

<Tabs class="-code">
  <Tab label="Product.ts">

```typescript
import {CustomKey} from "@tsed/schema";
import {Range, ExclusiveRange} from "../decorators/Range"; // custom decorator

export class Product {
  @CustomKey("range", [10, 100])
  @CustomKey("exclusiveRange", true)
  price: number;

  // OR

  @Range(10, 100)
  @ExclusiveRange(true)
  price2: number;
}
```

  </Tab>
  <Tab label="Range.ts">

```typescript
import {CustomKey} from "@tsed/schema";

export function Range(min: number, max: number) {
  return CustomKey("range", [min, max]);
}

export function ExclusiveRange(bool: boolean) {
  return CustomKey("exclusiveRange", bool);
}
```

  </Tab>
</Tabs>

Finally, we can create a unit test to verify if our example works properly:

```typescript
import "@tsed/ajv";
import {PlatformTest} from "@tsed/common";
import {getJsonSchema} from "@tsed/schema";
import {Product} from "./Product";
import "../keywords/RangeKeyword";

describe("Product", () => {
  beforeEach(PlatformTest.create);
  afterEach(PlatformTest.reset);

  it("should call custom keyword validation (compile)", () => {
    const ajv = PlatformTest.get<Ajv>(Ajv);
    const schema = getJsonSchema(Product, {customKeys: true});
    const validate = ajv.compile(schema);

    expect(schema).to.deep.equal({
      properties: {
        price: {
          exclusiveRange: true,
          range: [10, 100],
          type: "number"
        }
      },
      type: "object"
    });

    expect(validate({price: 10.01})).toEqual(true);
    expect(validate({price: 99.99})).toEqual(true);
    expect(validate({price: 10})).toEqual(false);
    expect(validate({price: 100})).toEqual(false);
  });
});
```

## Groups

@@Groups@@ decorator allows you to manage your serialized/deserialized fields by using group label. For example, with a
CRUD controller, you can have many methods like `POST`, `PUT`, `GET` or `PATCH` to manage `creation`, `update`
and `read` usecases for the exposed resource.

For the creation, you don't need to have the `id` field but for the update, you need to have it. With the previous
version for Ts.ED, you had to create the model twice, one for the `creation` (without `id`) and another one for `update`
and `read` (with `id`). Managing many models can be a pain point for the developer, this is why the @@Groups@@ decorator
exists.

For example, we have a User model with the following properties:

<<< @/docs/snippets/model/group-user.ts

**Explanation:**

- `!creation`: This annotation indicates that the field will never be exposed when using the `creation` group.
- `group.email`: This annotation indicates that the field will be exposed only if the group match with `group.email` or
  with a glob pattern like `group.*`.

So by using the @@deserialize@@ function with the extra groups options, we can map data to the expected user instance:

<Tabs class="-code">
<Tab label="Creation">

```typescript
import { deserialize } from '@tsed/json-mapper';

const result = deserialize<User>(
  {
    id: "id", // will be ignored because creation doesn't include `id` field
    firstName: "firstName",
    lastName: "lastName",
    email: "email@tsed.io",
    password: "password"
  },
  {type: User, groups: ["creation"]}
);

console.log(result); // User {firstName, lastName, email, password}
```

</Tab>
<Tab label="With group">

```typescript
import { deserialize } from '@tsed/json-mapper';

const result = deserialize<User>(
  {
    id: "id",
    firstName: "firstName",
    lastName: "lastName",
    email: "email@tsed.io",
    password: "password",
    roles: ["admin"]
  },
  {type: User, groups: ["group.email"]}
);

console.log(result); // User {id, firstName, lastName, email, password}
```

</Tab>
<Tab label="With glob pattern">

```typescript
import { deserialize } from '@tsed/json-mapper';

const result = deserialize<User>(
  {
    id: "id",
    firstName: "firstName",
    lastName: "lastName",
    email: "email@tsed.io",
    password: "password",
    roles: ["admin"]
  },
  {type: User, groups: ["group.*"]}
);

console.log(result); // User {id, firstName, lastName, email, password, roles}
```

</Tab>
</Tabs>

::: tip Note

The same principle works with the @@serialize@@ and @@getJsonSchema@@ functions!

:::

Now let's see how groups work with controllers.

<Tabs class="-code">
<Tab label="UsersCtrl.ts">

<<< @/docs/snippets/model/group-users-ctrl.ts

</Tab>
<Tab label="User.ts">

<<< @/docs/snippets/model/group-user.ts

</Tab>
<Tab label="OpenSpec">

<<< @/docs/snippets/model/group-users-openspec.json

</Tab>
</Tabs>

We can see that the @@Groups@@ decorator can be used on parameter level as well as on the method through the @@Returns@@
decorator. The generated OpenSpec will create automatically the appropriate JsonSchema according to the `groups`
configuration!

::: tip
You can combine different group labels or use a glob pattern to match multiple group labels. It's also possible
to use negation by prefixing the group label with `!`.
:::

## Groups Name

By default, Groups decorator generate automatically a name for each model impacted by the given groups list.
If you use a typed client http generator based on Swagger (OAS3) to generate the client code, this behavior can be a constraint for your consumer when you change the group list.

```ts
import {BodyParams, PathParams} from "@tsed/platform-params";
import {Get, Groups, Post, Returns} from "@tsed/schema";
import {Controller} from "@tsed/di";
import {User} from "../models/User";

@Controller("/")
export class UsersCtrl {
  @Get("/:id")
  @Returns(200, User).Groups("group.*")
  async get(@PathParams("id") id: string) {}

  @Post("/")
  @Returns(201, User).Groups("group.*")
  async post(@BodyParams() @Groups("creation", "summary") user: User) {}
}
```

In this example, the Groups annotation `@Groups("creation", "summary") user: User` will generate a new model name `UserCreationSummary`.
If you change the groups list by this one:

```
 @Groups("creation", "summary", "extra") user: User
```

The new model name will be `UserCreationSummaryExtra`. This change will break the entire consumer code by removing the `UserCreationSummary` type and giving a new `UserCreationSummaryExtra` type.
In fact, `UserCreationSummary` and `UserCreationSummaryExtra` are the same model with more fields!

In order to minimize the impact of this kind of change Ts.ED allows to configure the postfix added to each model impacted by the groups.

Here is an example with a configured GroupsName:

```ts
import {BodyParams, PathParams} from "@tsed/platform-params";
import {Get, Groups, Post, Returns} from "@tsed/schema";
import {Controller} from "@tsed/di";
import {User} from "../models/User";

@Controller("/")
export class UsersCtrl {
  @Get("/:id")
  @Returns(200, User).Groups("Details", ["group.*"])
  async get(@PathParams("id") id: string) {}

  @Post("/")
  @Returns(201, User).Groups("Details", ["group.*"])
  async post(@BodyParams() @Groups("Creation", ["creation", "summary"]) user: User) {}
}
```

Now, `@Groups("Creation", ["creation", "summary"]) user: User` will generate a `UserCreation` type and
`@Returns(200, User).Groups("Details", ["group.*"])` will generate a `UserDetails` type.

## Groups class definition

It's also possible to define all groups on class instead of declaring it on each property.

<Tabs class="-code">
<Tab label="UsersCtrl.ts">

<<< @/docs/snippets/model/group-users-ctrl-on-class.ts

</Tab>
<Tab label="User.ts">

<<< @/docs/snippets/model/group-user-on-class.ts

</Tab>
<Tab label="Creation">

<<< @/docs/snippets/model/group-user-creation.json

</Tab>
<Tab label="Update">

<<< @/docs/snippets/model/group-user-update.json

</Tab>
<Tab label="ChangePassword">

<<< @/docs/snippets/model/group-user-change-password.json

</Tab>
</Tabs>

## ForwardGroups

Groups configuration isn't forwarded to the nested models to avoid side effect on model generation.
With @@ForwardGroups@@ decorator, you are able to tell if a property should use or not the Groups configuration to generate correctly
a nested model.

```typescript
class ChildModel {
  @Groups("!creation")
  id: string;

  @Required()
  prop1: string;
}

class MyModel {
  @Groups("!creation")
  id: string;

  @Groups("group.summary")
  @Required()
  prop1: string;

  @Groups("group.extended")
  @Required()
  prop2: string;

  @Property()
  @Required()
  prop3: string;

  @CollectionOf(ChildModel)
  @ForwardGroups()
  prop4: ChildModel[];
}
```

Now `prop4` will have a `ChildModel` generated along to groups configuration.

## RequiredGroups

As @@Groups@@ decorator, @@RequiredGroups@@ allow you to define when a field is `required` depending on the given groups strategy.

The usage is the same as Groups:

```typescript
import {RequiredGroups, Groups, Required} from "@tsed/schema";

class MyModel {
  @Groups("!creation")
  id: string;

  @Required()
  prop1: string;

  @RequiredGroups("!patch")
  @Required()
  prop2: string;

  @RequiredGroups("patch")
  @Required()
  prop3: string;
}
```

## AllowedGroups

This feature let your API consumer to define which field he wants to consume. The server will filter automatically fields based on the @@Groups@@
strategy.

```typescript
class MyModel {
  @Property()
  id: string;

  @Property()
  description: string;

  @Groups("summary")
  prop1: string; // not display by default

  @Groups("details")
  prop2: string; // not display by default

  @Groups("admin")
  sensitiveProp: string; // not displayed because it's a sensitive props
}

@Controller("/controllers")
class MyController {
  @Get("/:id")
  @Returns(200, MyModel).Groups("!admin").AllowedGroups("summary", "details")
  get() {
    return {
      id: "id",
      description: "description",
      prop1: "prop1",
      prop2: "prop2",
      sensitiveProp: "sensitiveProp"
    };
  }
}
```

The AllowedGroups is enabled while `includes` query params is given in the request. Here the different scenario with this parameter:

<Tabs>
 <Tab label="Basic usage">

Request:

```
GET http://host/rest/controllers/1?includes=summary
```

The response will be:

```json
{
  "id": "id",
  "description": "description",
  "prop1": "prop1"
}
```

 </Tab>
 <Tab label="Multiple includes">

Request:

```
GET http://host/rest/controllers/1?includes=summary&includes=details

OR

GET http://host/rest/controllers/1?includes=summary,details
```

Expected json:

```json
{
  "id": "id",
  "description": "description",
  "prop1": "prop1",
  "prop2": "prop2"
}
```

 </Tab>
 <Tab label="Without includes">

Request:

```
GET http://host/rest/controllers/1
```

Expected json:

```json
{
  "id": "id",
  "description": "description",
  "prop1": "prop1",
  "prop2": "prop2"
}
```

 </Tab>
 <Tab label="Unexpected includes">

If a given value isn't listed in the allowed groups, the value will be ignored!

Request:

```
GET http://host/rest/controllers/1?includes=admin
```

Expected json:

```json
{
  "id": "id",
  "description": "description",
  "prop1": "prop1",
  "prop2": "prop2"
}
```

 </Tab>
</Tabs>

## Partial

Partial allow you to create a Partial model on an endpoint:

```typescript
import {Returns, Patch, Partial} from "@tsed/schema";
import {Controller} from "@tsed/common";
import {BodyParams} from "./bodyParams";

@Controller("/")
class MyController {
  @Patch("/")
  @Returns(200, MyModel).Groups("group.*")
  async patch(@BodyParams() @Partial() payload: MyModel) {
    // ...
  }
}
```

## Advanced validation

### BeforeDeserialize

If you want to validate or manipulate data before the model has been deserialized you can use the @@BeforeDeserialize@@ decorator.

::: tip Note
Don't forget to return the data in your callback function otherwise an error will occur.
:::

```typescript
import {Enum, Property} from "@tsed/schema";
import {BeforeDeserialize} from "@tsed/json-mapper";
import {BadRequest} from "@tsed/exceptions";

enum AnimalType {
  DOG = "DOG",
  CAT = "CAT"
}

@BeforeDeserialize((data: Record<string, unknown>) => {
  if (data.type !== AnimalType.DOG) {
    throw new BadRequest("Sorry, we're only responsible for dogs");
  } else {
    data.name = `Our dog ${data.name}`;
    return data;
  }
})
export class Animal {
  @Property()
  name: string;
  @Enum(AnimalType)
  type: AnimalType;
}
```

### AfterDeserialize

If you want to validate or manipulate data after the model has been deserialized you can use the @@AfterDeserialize@@ decorator.

::: tip Note
Don't forget to return the data in your callback function otherwise an error will occur.
:::

```typescript
import {Enum, Property} from "@tsed/schema";
import {AfterDeserialize} from "@tsed/json-mapper";
import {BadRequest} from "@tsed/exceptions";

enum AnimalType {
  DOG = "DOG",
  CAT = "CAT"
}

@AfterDeserialize((data: Animal) => {
  if (data.type !== AnimalType.CAT) {
    throw new BadRequest("Sorry, we're only responsible for cats");
  } else {
    data.name = `Our cat ${data.name}`;
    return data;
  }
})
export class Animal {
  @Property()
  name: string;
  @Enum(AnimalType)
  type: AnimalType;
}
```

### Custom validation decorator

Validation can quickly become complex and therefore confusing. In this case you can use your own validation decorator.

```typescript
import {BeforeDeserialize} from "@tsed/json-mapper";
import {Property, JsonEntityFn} from "@tsed/schema";
import {BadRequest} from "@tsed/exceptions";

class Company {
  @Property()
  name: string;
  @Property()
  @RequiredIf((value: any, data: any) => data.name === "tsed" && value !== undefined)
  location: string;
}

function RequiredIf(cb: any): PropertyDecorator {
  return JsonEntityFn((store, [target, propertyKey]) => {
    BeforeDeserialize((data) => {
      if (!cb(data[propertyKey], data)) {
        throw new BadRequest(`${String(propertyKey)} is required`);
      }
      return data;
    })(target);
  });
}
```

## Discriminator <Badge text="v7.8.0+" />

The discriminator feature allows polymorphism with JsonSchema and OpenAPI.
Although @@OneOf@@ already allows polymorphism in terms of validation, the latter doesn't allow the `@tsed/json-mapper` to render the correct class type during the deserialization (plain object to class).

By declaring a discriminatorKey, `@tsed/json-mapper` will be able to determine the correct class which should be used.

Here is an example:

```typescript
import {Discriminator, DiscriminatorKey, DiscriminatorValue, Property, Required, OneOf} from "@tsed/schema";

export class Event {
  @DiscriminatorKey() // declare this property as discriminator key
  type: string;

  @Property()
  value: string;
}

@DiscriminatorValue("page_view")
// or @DiscriminatorValue() value can be inferred by the class name (ex: "page_view")
export class PageView extends Event {
  @Required()
  url: string;
}

@DiscriminatorValue("action", "click_action")
export class Action extends Event {
  @Required()
  event: string;
}

export class Tracking {
  @OneOf(Action, PageView)
  data: Action | PageView;
}
```

And now we can use `deserialize` to map plain object to a class:

```typescript
import {deserialize} from "@tsed/json-mapper";
import {Tracking} from "./Tracking";

const list = {
  data: [
    {
      type: "page_view",
      value: "value",
      url: "https://url"
    },
    {
      type: "action",
      value: "value",
      event: "event"
    },
    {
      type: "click_action",
      value: "value",
      event: "event"
    }
  ]
};

const result = deserialize(list, {
  type: Tracking
});

expect(result.data[0]).toBeInstanceOf(PageView);
expect(result.data[1]).toBeInstanceOf(Action);
expect(result.data[2]).toBeInstanceOf(Action);
expect(result.data[3]).toBeInstanceOf(CustomAction);
```

::: tip Shortcut

Declaring each time the list of children class using @@OneOf@@ decorator can be a pain point, so Ts.ED provide a way to simplify your code:

Instead of declaring all classes:

```ts
export class Tracking {
  @OneOf(Action, PageView)
  data: Action | PageView;
}
```

Give the parent class to `OneOf` decorator:

```typescript
export type EventsType = Action | PageView;

export class Tracking {
  @OneOf(Event)
  data: EventsType;
}
```

Ts.ED will automatically infer the children classes!
:::

Discriminator model can be used also on controller:

```typescript
@Controller("/")
class Test {
  @Put("/:id")
  @Returns(200).OneOf(Event)
  put(@PathParams(":id") id: string, @BodyParams() @OneOf(Event) event: EventsType) {
    return [];
  }
}
```

## Generics

### Declaring a generic model

Sometimes, it might be useful to use generic models. TypeScript doesn't store the generic type in the metadata. This is
why we need to declare explicitly the generic models with the decorators.

One of the generic's usage can be a paginated list. With Returns decorator, it's now possible to declare generic type
and generate the appropriate OpenSpec documentation.

Starting with the pagination model, by using @@Generics@@ and @@CollectionOf@@:

<<< @/docs/snippets/model/generics-pagination.ts

Now, we need a model to be used with the generic Pagination model:

<<< @/docs/snippets/model/generics-product.ts

Finally, we can use our models on a method as following:

<Tabs class="-code">
 <Tab label="MyController.ts">

<<< @/docs/snippets/model/generics-controller1.ts

 </Tab>
 <Tab label="OpenSpec 2">

<<< @/docs/snippets/model/generics-controller1-os2.json

 </Tab>
 <Tab label="OpenSpec 3">

<<< @/docs/snippets/model/generics-controller1-os3.json

 </Tab>
</Tabs>

### Declaring nested generic models

It's also possible to declare nested generic models in order to have this type `Pagination<Submission<Product>>`:

<Tabs class="-code">
  <Tab label="MyController.ts">

```typescript
import {Generics, Property, Returns} from "@tsed/schema";
import {Post} from "@tsed/common";

class MyController {
  @Post("/")
  @Returns(200, Pagination).Of(Submission).Nested(Product).Description("description")
  async method(): Promise<Pagination<Submission<Product>> | null> {
    return null;
  }
}
```

  </Tab>
  <Tab label="Submission.ts">

<<< @/docs/snippets/model/generics-submission.ts

  </Tab>
  <Tab label="Pagination.ts">

<<< @/docs/snippets/model/generics-pagination.ts

  </Tab>
  <Tab label="Product.ts">

<<< @/docs/snippets/model/generics-product.ts

  </Tab>
 <Tab label="OpenSpec 2">

<<< @/docs/snippets/model/generics-controller2-os2.json

 </Tab>
 <Tab label="OpenSpec 3">

<<< @/docs/snippets/model/generics-controller2-os3.json

 </Tab>  
</Tabs>

### Generics with Types

<Tabs class="-code">
 <Tab label="String">

<<< @/docs/snippets/model/generic-string.ts

 </Tab>
 <Tab label="Date">

<<< @/docs/snippets/model/generic-date.ts

 </Tab>
 <Tab label="Date">

<<< @/docs/snippets/model/generic-enum.ts

 </Tab>
</Tabs>

### Generics with Functional API

<Tabs class="-code">
 <Tab label="String">

<<< @/docs/snippets/model/generic-string-api.ts

 </Tab>
 <Tab label="Date">

<<< @/docs/snippets/model/generic-date-api.ts

 </Tab>
</Tabs>

## Pagination

The following advanced example will show you how you can combine the different Ts.ED features to describe Pagination.
The used features are the following:

- [Generics](/docs/model.html#generics)
- [Function programming to declare models](/docs/model.html#using-functions)
- @@For@@ decorator to declare a custom model for JsonSchema, OS2 or OS3.
- [Response Filter](/docs/response-filter.md) to manage paginated response.

<Tabs class="-code">
  <Tab label="ProductsCtrl.ts">

<<< @/docs/snippets/model/pagination-ctrl.ts

  </Tab>  
  <Tab label="Pageable.ts">

<<< @/docs/snippets/model/pageable-model.ts

  </Tab>  
  <Tab label="Pagination.ts">

<<< @/docs/snippets/model/pagination-model.ts

  </Tab>
  <Tab label="Product.ts">

<<< @/docs/snippets/model/pageable-product-model.ts

  </Tab>
  <Tab label="PaginationFilter.ts">

<<< @/docs/snippets/model/pagination-filter.ts

  </Tab>
  <Tab label="ProductsCtrl.spec.ts">

<<< @/docs/snippets/model/pageable-product-model.ts

  </Tab>
</Tabs>

## Deep object on query

With OpenAPI 3, it's possible to describe and use a [deepObject](https://swagger.io/docs/specification/serialization/#query) `style` as Query params.
It means, a consumer can call your endpoint with the following url:

```
/users?id[role]=admin&id[firstName]=Alex
```

Ts.ED will determine automatically the appropriate `style` parameter based on the given `User` model.
Here is an example with a DeepQueryObject model:

```typescript
class DeepQueryObject {
  @Property()
  path: string;

  @Property()
  condition: string;

  @Property()
  value: string;
}

@Path("/test")
class TestDeepObjectCtrl {
  @OperationPath("GET", "/")
  async get(@QueryParams("s") q: DeepQueryObject) {}
}
```

The url to be called will be:

```
/test?s[path]=title&s[condition]=eq&s[value]=tsed
```

And the generated swagger will be:

```json
{
  "components": {
    "schemas": {
      "DeepQueryObject": {
        "properties": {
          "condition": {
            "type": "string"
          },
          "path": {
            "type": "string"
          },
          "value": {
            "type": "string"
          }
        },
        "type": "object"
      }
    }
  },
  "paths": {
    "/test": {
      "get": {
        "operationId": "testDeepObjectCtrlGet",
        "parameters": [
          {
            "in": "query",
            "name": "s",
            "required": false,
            "style": "deepObject",
            "schema": {
              "$ref": "#/components/schemas/DeepQueryObject"
            }
          }
        ]
      }
    }
  }
}
```

::: tip

Ts.ED support also Generics Deep object style!

```typescript
class FindQuery {
  @Property()
  tableColumnNameA?: number;

  @Property()
  tableColumnNameB?: number;
}

@Generics("T")
class PaginationQuery<T> {
  @Minimum(0)
  @Default(0)
  offset?: number;

  @Minimum(1)
  @Maximum(1000)
  @Default(50)
  limit?: number;

  @Property("T")
  where?: T;
}

@Path("/test")
class TestDeepObjectCtrl {
  @OperationPath("GET", "/")
  async get(@QueryParams() @GenericOf(FindQuery) q: PaginationQuery<FindQuery>) {}
}
```

:::

::: warning
This feature is only available for OpenAPI 3.
:::

## Annotations

JSON Schema includes a few keywords and Ts.ED provide also theses corresponding decorators like @@Title@@,
@@Description@@, @@Default@@, @@Example@@ that arenâ€™t strictly used for validation, but are used to describe parts of a
schema.

None of these `annotation` keywords are required, but they are encouraged for good practice, and can make your
schema `self-documenting`.

<Tabs class="-code">
  <Tab label="Model">

<<< @/docs/snippets/model/annotations.ts

  </Tab>
  <Tab label="Json schema">

<<< @/docs/snippets/model/annotations.json

  </Tab>
</Tabs>

## Alias

@@Name@@ decorator lets you rename the exposed property in your json schema.

For example mongo db uses the `_id` property. In order not to give any indication to our consumer about the nature of
the database, it's better to rename the property to `id`.

<<< @/docs/snippets/model/name.ts

## Set Schema

If Ts.ED doesn't provide the expected decorator to describe your json schema, you can use the @@Schema@@ decorator
from `@tsed/common` to set a custom schema.

### Using JsonSchemaObject

You can declare schema by using the @@JsonSchemaObject@@ interface:

<<< @/docs/snippets/model/raw-schema-controller.ts

### Using functions

It's also possible to write a valid JsonSchema by using the functional approach (Joi like):

<<< @/docs/snippets/model/functional-schema-controller.ts

Here is the list of available functions:

<ApiList query="status.includes('schemaFunctional')" />

## RecordOf

The @@RecordOf@@ decorator constructs a json schema object type which property keys are set by a given set of keys
and which property values are of a given type.

<Tabs class="-code">
  <Tab label="Model">

<<< @/docs/snippets/model/record-of.ts

  </Tab>
  <Tab label="Json schema">

<<< @/docs/snippets/model/record-of.json

  </Tab>
</Tabs>

## Get Json schema

In some cases, it may be useful to retrieve the JSON Schema from a Model to use with another library. This is possible
by using @@getJsonSchema@@. Here is a small example:

<Tabs class="-code">
  <Tab label="Model">

<<< @/docs/snippets/model/jsonschema.ts

  </Tab>
  <Tab label="Json schema">

<<< @/docs/snippets/model/jsonschema.json

  </Tab>
</Tabs>

## Expose a JsonSchema

You can create a controller, or an endpoint to expose a specific schema with the custom keys. This can allow your
consumers to retrieve a validation template so that they can use it to validate a form.

```typescript
import {Controller, Get} from "@tsed/common";
import {getJsonSchema} from "@tsed/schema";
import {Product} from "../models/Product";

@Controller("/products")
export class ProductsCtrl {
  @Get("/.schema")
  get(@QueryParams("customKeys") customKeys: boolean, @QueryParams("groups") groups: string[]) {
    return getJsonSchema(Product, {customKeys, groups});
  }
}
```

## Get OpenSpec

In some cases, it may be useful to retrieve the OpenSpec from a Controller to generate the Swagger OpenSpec. This is
possible by using @@getSpec@@. Here is a small example:

<Tabs class="-code">
  <Tab label="MyController">

<<< @/docs/snippets/model/get-spec-generics-controller1.ts

  </Tab>
  <Tab label="OpenSpec">

<<< @/docs/snippets/model/generics-controller1-os3.json

  </Tab>
</Tabs>

## Decorators

<ApiList query="status.includes('decorator') && status.includes('schema')" />
