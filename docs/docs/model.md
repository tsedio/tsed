---
meta:
 - name: description 
   content: Documentation over Models and decorators provided by Ts.ED framework. Use decorator to build your model and JsonSchema.
 - name: keywords
   content: class model decorators ts.ed express typescript node.js javascript jsonschema
---
# Model

The classes can be used as a model in your application. Ts.ED uses these models to convert JSON objects to their class
equivalents.

The classes models can be used in the following cases:

- Data serialization and deserialization ([Json mapping](/docs/converters.md)),
- Data validation with [AJV](/tutorials/ajv.md) or any library compatible with [JsonSchema](https://json-schema.org/),
- Generating documentation with [Swagger](/tutorials/swagger.md).

To create a model, Ts.ED provides decorators which will store and generate a
standard [JsonSchema](http://json-schema.org/) model.

::: warning Validation is only available when you import `@tsed/ajv` package in your server.

```typescript
import {Configuration} from "@tsed/common";
import "@tsed/ajv";

@Configuration()
class Server {
}
```

Without this package, decorators like @@Email@@ won't have any effect.
:::

## Example

The example below uses decorators to describe a property of the class and store metadata such as the description of the
field.

<<< @/docs/snippets/model/example.ts

::: tip The Model will generate a JsonSchema which can be used by modules supporting JsonSchema spec
:::

::: warning The schema generated by Ts.ED lists only properties decorated by at least one decorator. In the previous
example, the `_id` won't be displayed in the JsonSchema. It's very important to understand that **TypeScript** only
generates metadata on properties with at least one of these decorators:

<ApiList query="module === '@tsed/schema' && status.includes('decorator') && status.includes('schema')" />

:::

Our model is now described, we can use it inside a @@Controller@@ as input type parameter for our methods. Ts.ED will
use the model to convert the raw data to an instance of your model.

<<< @/docs/snippets/model/controller.ts

## Primitives

Just use at least @@Property@@ decorator any other `schema` decorator (like @@Email@@), to create a new property on a
model. Ts.ED will get the type from Typescript metadata and transform this type to a valid Json type.

<Tabs class="-code">
  <Tab label="Model">

<<< @/docs/snippets/model/primitives.ts

  </Tab>
  <Tab label="Json schema">

<<< @/docs/snippets/model/primitives.json

  </Tab>
</Tabs>

## Integer

The @@Integer@@ decorator is used to set integer type for integral numbers.

<Tabs class="-code">
  <Tab label="Model">

<<< @/docs/snippets/model/integer.ts

  </Tab>
  <Tab label="Json schema">

<<< @/docs/snippets/model/integer.json

  </Tab>
</Tabs>

## Any types

The @@Any@@, decorator is used to set one or more types on property. Use this method when you want to set explicitly the
json type or when you use a mixed TypeScript types.

<Tabs class="-code">
  <Tab label="Model">

<<< @/docs/snippets/model/any-types.ts

  </Tab>
  <Tab label="Json schema">

<<< @/docs/snippets/model/any-types.json

  </Tab>
</Tabs>

## Nullable <Badge text="6.25.0+"/>

The @@Nullable@@ decorator is used allow a null value on a field while preserving the original Typescript type.

<Tabs class="-code">
  <Tab label="Model">

<<< @/docs/snippets/model/nullable-properties.ts

  </Tab>
  <Tab label="Json schema">

<<< @/docs/snippets/model/nullable-properties.json

  </Tab>
</Tabs>

## Regular expressions

The @@Pattern@@ decorator is used to restrict a string to a particular regular expression. The regular expression syntax
is the one defined in JavaScript ([ECMA 262](https://www.ecma-international.org/publications/standards/Ecma-262.htm)
specifically).
See [Regular Expressions](https://json-schema.org/understanding-json-schema/reference/regular_expressions.html#regular-expressions)
for more information.

<Tabs class="-code">
  <Tab label="Model">

<<< @/docs/snippets/model/pattern.ts

  </Tab>
  <Tab label="Json schema">

<<< @/docs/snippets/model/pattern.json

  </Tab>
</Tabs>

## Format

The @@Format@@ decorator allows basic semantic validation on certain kinds of string values that are commonly used. This
allows values to be constrained beyond what the other tools in JSON Schema,
including [Regular Expressions](https://json-schema.org/understanding-json-schema/reference/regular_expressions.html#regular-expressions)
can do.

<Tabs class="-code">
  <Tab label="Model">

<<< @/docs/snippets/model/format.ts

  </Tab>
  <Tab label="Json schema">

<<< @/docs/snippets/model/format.json

  </Tab>
</Tabs>

The following formats are supported for string validation with `format` keyword by [AJV](https://ajv.js.org/):

- **date**: full-date according to [RFC3339](https://json-schema.org/latest/json-schema-validation.html#RFC3339).
- **time**: time with optional time-zone.
- **date-time**: date-time from the same source (time-zone is mandatory).
- **uri**: full uri with optional protocol.
- **email**: email address.
- **hostname**: host name according to [RFC1034](https://tools.ietf.org/html/rfc1034#section-3.1).
- **ipv4**: IP address v4.
- **ipv6**: IP address v6.
- **regex**: tests whether a string is a valid regular expression by passing it to RegExp constructor.

See built-in formats types
on [Jsonp-schema.org](https://json-schema.org/understanding-json-schema/reference/string.html#built-in-formats) for more
details:

## MultipleOf

Numbers can be restricted to a multiple of a given number, using the @@MultipleOf@@ decorator. It may be set to any
positive number.
See [json-schema documentation](https://json-schema.org/understanding-json-schema/reference/numeric.html#multiples) for
more details.

<Tabs class="-code">
  <Tab label="Model">

<<< @/docs/snippets/model/multiple-of.ts

  </Tab>
  <Tab label="Json schema">

<<< @/docs/snippets/model/multiple-of.json

  </Tab>
</Tabs>

## Ranges

Ranges of numbers are specified using a combination of the @@Minimum@@ and @@Maximum@@ decorators, (or
@@ExclusiveMinimum@@ and @@ExclusiveMaximum@@ for expressing exclusive range).
See [json-schema documentation](https://json-schema.org/understanding-json-schema/reference/numeric.html#multiples) for
more details.

<Tabs class="-code">
  <Tab label="Model">

<<< @/docs/snippets/model/ranges.ts

  </Tab>
  <Tab label="Json schema">

<<< @/docs/snippets/model/ranges.json

  </Tab>
</Tabs>

## Enumerated values

The @@Enum@@ decorator is used to restrict a value to a fixed set of values. It must be an array with at least one
element, where each element is unique or a TypeScript enum.

<Tabs class="-code">
  <Tab label="Model">

<<< @/docs/snippets/model/enumerated-values.ts

  </Tab>
  <Tab label="Json schema">

<<< @/docs/snippets/model/enumerated-values.json

  </Tab>
</Tabs>

@@Enum@@ decorator can be also in combination with @@BodyParams@@ or @QueryParams@@:

```typescript
import {Enum} from "@tsed/schema";
import {QueryParams, Controller} from "@tsed/common";

@Controller("/")
class MyController {
  @Post("/")
  async method(@QueryParams('type') @Enum(MyEnum) type: MyEnum): Promise<any> {
    return null;
  }
}
```

## Constant values

The @@Const@@ decorator is used to restrict a value to a single value. For example, if you only support shipping to the
United States for export reasons:

<Tabs class="-code">
  <Tab label="Model">

<<< @/docs/snippets/model/required-properties.ts

  </Tab>
  <Tab label="Json schema">

<<< @/docs/snippets/model/required-properties.json

  </Tab>
</Tabs>

## Collections

Declaring a property that uses a collection is a bit different than declaring a simple property. TypeScript stores only
the `Array`/`Set`/`Map` type when you declare the type of your property. The type used by the collection is lost.

To tell Ts.ED (and other third party which uses JsonSchema) that a property uses a collection with a specific type, you
must use @@CollectionOf@@ (before v5.62.0, use @@PropertyType@@) decorator as following:

<Tabs class="-code">
  <Tab label="Model">

<<< @/docs/snippets/model/collections.ts

  </Tab>
  <Tab label="Json schema">

<<< @/docs/snippets/model/collections.json

  </Tab>
</Tabs>

Ts.ED provides others related collection decorators:

<ApiList query="status.includes('decorator') && status.includes('schema') && status.includes('collections')" />

## Required properties

By default, the properties defined with a decorator are not `required`. However, one can use @@Required@@ decorator to
add a required property to the json schema.

## Additional properties

Sometimes, it can be useful to create model with additional properties. By default, Json schema is strict over extra
properties not declared in a model (
see [Properties json schema documentation](https://json-schema.org/understanding-json-schema/reference/object.html#properties))
.

Use @@AdditionalProperties@@ on your model to allow this behavior:

<Tabs class="-code">
  <Tab label="Model">

<<< @/docs/snippets/model/additional-properties.ts

  </Tab>
  <Tab label="Json schema">

<<< @/docs/snippets/model/additional-properties.json

  </Tab>
</Tabs>

It is also possible to add contraint on additional properties, by giving a raw Json schema:

<Tabs class="-code">
  <Tab label="Model">

<<< @/docs/snippets/model/additional-properties-with-schema.ts

  </Tab>
  <Tab label="Json schema">

<<< @/docs/snippets/model/additional-properties-with-schema.json

  </Tab>
</Tabs>

Or by using @@getJsonSchema@@ in combination with @@AdditionalProperty@@ as following:

<Tabs class="-code">
  <Tab label="Model">

<<< @/docs/snippets/model/additional-properties-with-model.ts

  </Tab>
  <Tab label="Json schema">

<<< @/docs/snippets/model/additional-properties-with-model.json

  </Tab>
</Tabs>

## Circular ref

Circular reference can be resolved by using arrow with a @@Property@@ and @@CollectionOf@@ decorators:

<<< @/docs/snippets/model/circular-references.ts

## Custom Keys <Badge text="6.17.0+"/>

Ts.ED introduces the @@Keyword@@ decorator to declare a new custom validator for Ajv. Combined with the @@CustomKey@@
decorator to add keywords to a property of your class, you can use more complex scenarios than what basic JsonSchema
allows.

For example, we can create a custom validator to support the `range` validation over a number. To do that, we have to
define the custom validator by using @@Keyword@@ decorator:

```typescript
import {Keyword, KeywordMethods} from "@tsed/ajv";
import {array, number} from "@tsed/schema";

@Keyword({
  keyword: "range",
  type: "number",
  schemaType: "array",
  implements: ["exclusiveRange"],
  metaSchema: array()
    .items([number(), number()])
    .minItems(2)
    .additionalItems(false)
})
class RangeKeyword implements KeywordMethods {
  compile([min, max]: number[], parentSchema: any) {
    return parentSchema.exclusiveRange === true
      ? (data: any) => data > min && data < max
      : (data: any) => data >= min && data <= max;
  }
}
```

Then we can declare a model using the standard decorators from `@tsed/schema`:

<Tabs class="-code">
  <Tab label="Product.ts">

```typescript
import {CustomKey} from "@tsed/schema";
import {Range, ExclusiveRange} from "../decorators/Range"; // custom decorator

export class Product {
  @CustomKey("range", [10, 100])
  @CustomKey("exclusiveRange", true)
  price: number;

  // OR

  @Range(10, 100)
  @ExclusiveRange(true)
  price2: number;
}
```

  </Tab>
  <Tab label="Range.ts">

```typescript
import {CustomKey} from "@tsed/schema";

export function Range(min: number, max: number) {
  return CustomKey("range", [min, max]);
}

export function ExclusiveRange(bool: boolean) {
  return CustomKey("exclusiveRange", bool);
}
```     

  </Tab>
</Tabs>

Finally, we can create a unit test to verify if our example works properly:

```typescript
import "@tsed/ajv";
import {PlatformTest} from "@tsed/common";
import {getJsonSchema} from "@tsed/schema";
import {Product} from "./Product";
import "../keywords/RangeKeyword";

describe("Product", () => {
  beforeEach(PlatformTest.create);
  afterEach(PlatformTest.reset);

  it("should call custom keyword validation (compile)", () => {
    const ajv = PlatformTest.get<Ajv>(Ajv);
    const schema = getJsonSchema(Product, {customKeys: true});
    const validate = ajv.compile(schema);

    expect(schema).to.deep.equal({
      "properties": {
        "price": {
          "exclusiveRange": true,
          "range": [
            10,
            100
          ],
          "type": "number"
        }
      },
      "type": "object"
    });

    expect(validate({price: 10.01})).toEqual(true);
    expect(validate({price: 99.99})).toEqual(true);
    expect(validate({price: 10})).toEqual(false);
    expect(validate({price: 100})).toEqual(false);
  });
});
```

## Groups <Badge text="6.14.0+"/>

@@Groups@@ decorator allows you to manage your serialized/deserialized fields by using group label. For example, with a
CRUD controller, you can have many methods like `POST`, `PUT`, `GET` or `PATCH` to manage `creation`, `update`
and `read` usecases for the exposed resource.

For the creation, you don't need to have the `id` field but for the update, you need to have it. With the previous
version for Ts.ED, you had to create the model twice, one for the `creation` (without `id`) and another one for `update`
and `read` (with `id`). Managing many models can be a pain point for the developer, this is why the @@Groups@@ decorator
exists.

For example, we have a User model with the following properties:

<<< @/docs/snippets/model/group-user.ts

**Explanation:**

- `!creation`: This annotation indicates that the field will never be exposed when using the `creation` group.
- `group.email`: This annotation indicates that the field will be exposed only if the group match with `group.email` or
  with a glob pattern like `group.*`.

So by using the @@deserialize@@ function with the extra groups options, we can map data to the expected user instance:

<Tabs class="-code">
<Tab label="Creation">

```typescript
import {deserialize} from "json-schema";

const result = deserialize({
  id: "id", // will be ignored because creation doesn't include `id` field
  firstName: "firstName",
  lastName: "lastName",
  email: "email@tsed.io",
  password: "password"
}, {type: User, groups: ['creation']});

console.log(result); // User {firstName, lastName, email, password}
```

</Tab>
<Tab label="With group">

```typescript
import {deserialize} from "json-schema";

const result = deserialize({
  id: "id",
  firstName: "firstName",
  lastName: "lastName",
  email: "email@tsed.io",
  password: "password",
  roles: ['admin']
}, {type: User, groups: ['group.email']});

console.log(result); // User {id, firstName, lastName, email, password}
```

</Tab>
<Tab label="With glob pattern">

```typescript
import {deserialize} from "json-schema";

const result = deserialize({
  id: "id",
  firstName: "firstName",
  lastName: "lastName",
  email: "email@tsed.io",
  password: "password",
  roles: ['admin']
}, {type: User, groups: ['group.*']});

console.log(result); // User {id, firstName, lastName, email, password, roles}
```

</Tab>
</Tabs>

::: tip Note The same principle works with the @@serialize@@ and @@getJsonSchema@@ functions!
:::

Now let's see how groups work with controllers.

<Tabs class="-code">
<Tab label="UsersCtrl.ts">

<<< @/docs/snippets/model/group-users-ctrl.ts

</Tab>
<Tab label="User.ts">

<<< @/docs/snippets/model/group-user.ts

</Tab>
<Tab label="OpenSpec">

<<< @/docs/snippets/model/group-users-openspec.json

</Tab>
</Tabs>

We can see that the @@Groups@@ decorator can be used on parameter level as well as on the method through the @@Returns@@
decorator. The generated OpenSpec will create automatically the appropriate JsonSchema according to the `groups`
configuration!

::: tip You can combine different group labels or use a glob pattern to match multiple group labels. It's also possible
to use negation by prefixing the group label with `!`.
:::

## Groups class definition <Badge text="6.48.0+" />

It's also possible to define all groups on class instead of declaring it on each property.

<Tabs class="-code">
<Tab label="UsersCtrl.ts">

<<< @/docs/snippets/model/group-users-ctrl-on-class.ts

</Tab>
<Tab label="User.ts">

<<< @/docs/snippets/model/group-user-on-class.ts

</Tab>
<Tab label="Creation">

<<< @/docs/snippets/model/group-user-creation.json

</Tab>
<Tab label="Update">

<<< @/docs/snippets/model/group-user-update.json

</Tab>
<Tab label="ChangePassword">

<<< @/docs/snippets/model/group-user-change-password.json

</Tab>
</Tabs>

## ForwardGroups <Badge text="6.42.0+" />

Groups configuration isn't forwarded to the nested models to avoid side effect on model generation.
With @@ForwardGroups@@ decorator, your are able to tell if a property should use or not the Groups configuration to generate correctly 
a nested model.

```typescript
class ChildModel {
  @Groups("!creation")
  id: string;

  @Required()
  prop1: string;
}

class MyModel {
  @Groups("!creation")
  id: string;

  @Groups("group.summary")
  @Required()
  prop1: string;

  @Groups("group.extended")
  @Required()
  prop2: string;

  @Property()
  @Required()
  prop3: string;

  @CollectionOf(ChildModel)
  @ForwardGroups()
  prop4: ChildModel[];
}
```
Now `prop4` will have a `ChildModel` generated along to groups configuration.

## RequiredGroups <Badge text="6.34.0+"/>

As @@Groups@@ decorator, @@RequiredGroups@@ allow you to define when a field is `required` depending on the given groups strategy.

The usage is the same as Groups:

```typescript
import {RequiredGroups, Groups, Required} from "@tsed/schema";

class MyModel {
  @Groups("!creation")
  id: string;

  @Required()
  prop1: string;

  @RequiredGroups("!patch")
  @Required()
  prop2: string;

  @RequiredGroups("patch")
  @Required()
  prop3: string;
}
```

## Partial <Badge text="6.58.0+"/>

Partial allow you to create a Partial model on an endpoint:

```typescript
import {Returns, Patch, Partial} from "@tsed/schema";
import {Controller} from "@tsed/common";
import {BodyParams} from "./bodyParams";

@Controller("/")
class MyController {
  @Patch("/")
  @(Returns(200, MyModel).Groups("group.*"))
  async patch(@BodyParams() @Partial() payload: MyModel) {
    // ...
  }
}
```

## Advanced validation
### BeforeDeserialize <Badge text="6.39.0+"/>

If you want to validate or manipulate data before the model has been deserialized you can use the @@BeforeDeserialize@@ decorator.

::: tip Note 
Don't forget to return the data in your callback function otherwise an error will occur.
:::

```typescript
import {Enum, Property} from "@tsed/schema"; 
import {BeforeDeserialize} from "@tsed/json-mapper";
import {BadRequest} from "@tsed/exceptions";

enum AnimalType {
  DOG="DOG",
  CAT="CAT"
}

@BeforeDeserialize((data: Record<string, unknown>) => {
  if (data.type !== AnimalType.DOG) {
    throw new BadRequest("Sorry, we're only responsible for dogs")  
  } else {
    data.name = `Our dog ${data.name}`;
    return data;
  }
})
export class Animal {
    @Property()
    name: string;
    @Enum(AnimalType)
    type: AnimalType;
} 
```

### AfterDeserialize <Badge text="6.39.0+"/>

If you want to validate or manipulate data after the model has been deserialized you can use the @@AfterDeserialize@@ decorator.

::: tip Note 
Don't forget to return the data in your callback function otherwise an error will occur.
:::

```typescript
import {Enum, Property} from "@tsed/schema"; 
import {AfterDeserialize} from "@tsed/json-mapper";
import {BadRequest} from "@tsed/exceptions";

enum AnimalType {
  DOG="DOG",
  CAT="CAT"
}

@AfterDeserialize((data: Animal) => {
  if (data.type !== AnimalType.CAT) {
    throw new BadRequest("Sorry, we're only responsible for cats")  
  } else {
    data.name = `Our cat ${data.name}`;
    return data;
  }
})
export class Animal {
    @Property()
    name: string;
    @Enum(AnimalType)
    type: AnimalType;
} 
```

### Custom validation decorator

Validation can quickly become complex and therefore confusing. In this case you can use your own validation decorator.

```typescript
import {BeforeDeserialize} from "@tsed/json-mapper"; 
import {Property, JsonEntityFn} from "@tsed/schema";
import {BadRequest} from "@tsed/exceptions"; 

class Company {
  @Property()
  name: string;
  @Property()
  @RequiredIf((value: any, data: any) => data.name === "tsed" && value !== undefined)
  location: string;
}

function RequiredIf(cb: any): PropertyDecorator {
  return JsonEntityFn((store, [target, propertyKey]) => {
    BeforeDeserialize((data) => {
      if (!cb(data[propertyKey], data)) {
        throw new BadRequest(`${String(propertyKey)} is required`);
      }
      return data;
    })(target);
  });
}
```

## Generics
### Declaring a generic model

Sometimes, it might be useful to use generic models. TypeScript doesn't store the generic type in the metadata. This is
why we need to declare explicitly the generic models with the decorators.

One of the generic's usage can be a paginated list. With Returns decorator, it's now possible to declare generic type
and generate the appropriate OpenSpec documentation.

Starting with the pagination model, by using @@Generics@@ and @@CollectionOf@@:

<<< @/docs/snippets/model/generics-pagination.ts

Now, we need a model to be used with the generic Pagination model:

<<< @/docs/snippets/model/generics-product.ts

Finally, we can use our models on a method as following:

<Tabs class="-code">
 <Tab label="MyController.ts">

<<< @/docs/snippets/model/generics-controller1.ts

 </Tab>
 <Tab label="OpenSpec 2">

<<< @/docs/snippets/model/generics-controller1-os2.json

 </Tab>
 <Tab label="OpenSpec 3">

<<< @/docs/snippets/model/generics-controller1-os3.json

 </Tab>
</Tabs>

### Declaring nested generic models

It's also possible to declare nested generic models in order to have this type `Pagination<Submission<Product>>`:

<Tabs class="-code">
  <Tab label="MyController.ts">

```typescript
import {Generics, Property, Returns} from "@tsed/schema";
import {Post} from "@tsed/common";

class MyController {
  @Post("/")
  @Returns(200, Pagination).Of(Submission).Nested(Product).Description("description")
  async method(): Promise<Pagination<Submission<Product>> | null> {
    return null;
  }
}
```

  </Tab>
  <Tab label="Submission.ts">

<<< @/docs/snippets/model/generics-submission.ts

  </Tab>
  <Tab label="Pagination.ts">

<<< @/docs/snippets/model/generics-pagination.ts

  </Tab>
  <Tab label="Product.ts">

<<< @/docs/snippets/model/generics-product.ts

  </Tab>
 <Tab label="OpenSpec 2">

<<< @/docs/snippets/model/generics-controller2-os2.json

 </Tab>
 <Tab label="OpenSpec 3">

<<< @/docs/snippets/model/generics-controller2-os3.json

 </Tab>  
</Tabs>

### Generics with Types

<Tabs class="-code">
 <Tab label="String">

<<< @/docs/snippets/model/generic-string.ts

 </Tab>
 <Tab label="Date">

<<< @/docs/snippets/model/generic-date.ts

 </Tab>
 <Tab label="Date">

<<< @/docs/snippets/model/generic-enum.ts

 </Tab>
</Tabs>


### Generics with Functional API

<Tabs class="-code">
 <Tab label="String">

<<< @/docs/snippets/model/generic-string-api.ts

 </Tab>
 <Tab label="Date">

<<< @/docs/snippets/model/generic-date-api.ts

 </Tab>
</Tabs>

## Pagination

The following advanced example will show you how you can combine the different Ts.ED features to describe Pagination.
The used features are the following:

- [Generics](/docs/models.html#generics)
- [Function programming to declare models](/docs/models.html#using-functions)
- @@For@@ decorator to declare a custom model for JsonSchema, OS2 or OS3.
- [Response Filter](/docs/response-filter.md) to manage paginated response.

<Tabs class="-code">
  <Tab label="ProductsCtrl.ts">

<<< @/docs/snippets/model/pagination-ctrl.ts

  </Tab>  
  <Tab label="Pageable.ts">

<<< @/docs/snippets/model/pageable-model.ts


  </Tab>  
  <Tab label="Pagination.ts">

<<< @/docs/snippets/model/pagination-model.ts

  </Tab>
  <Tab label="Product.ts">

<<< @/docs/snippets/model/pageable-product-model.ts

  </Tab>
  <Tab label="PaginationFilter.ts">

<<< @/docs/snippets/model/pagination-filter.ts

  </Tab>
  <Tab label="ProductsCtrl.spec.ts">

<<< @/docs/snippets/model/pageable-product-model.ts

  </Tab>
</Tabs>

## Deep object on query <Badge text="6.64.2+"/>

With OpenAPI 3, it's possible to describe and use a [deepObject](https://swagger.io/docs/specification/serialization/#query) `style` as Query params.
It means, a consumer can call your endpoint with the following url:

```
/users?id[role]=admin&id[firstName]=Alex
```

Ts.ED will determine automatically the appropriate `style` parameter based on the given `User` model. 
Here is an example with a DeepQueryObject model:

```typescript
class DeepQueryObject {
  @Property()
  path: string;

  @Property()
  condition: string;

  @Property()
  value: string;
}

@Path("/test")
class TestDeepObjectCtrl {
  @OperationPath("GET", "/")
  async get(@QueryParams("s") q: DeepQueryObject) {

  }
}
```

The url to be called will be:

```
/test?s[path]=title&s[condition]=eq&s[value]=tsed
```

And the generated swagger will be:

```json
{
  "components": {
    "schemas": {
      "DeepQueryObject": {
        "properties": {
          "condition": {
            "type": "string"
          },
          "path": {
            "type": "string"
          },
          "value": {
            "type": "string"
          }
        },
        "type": "object"
      }
    }
  },
  "paths": {
    "/test": {
      "get": {
        "operationId": "testDeepObjectCtrlGet",
        "parameters": [
          {
            "in": "query",
            "name": "s",
            "required": false,
            "style": "deepObject",
            "schema": {
              "$ref": "#/components/schemas/DeepQueryObject"
            }
          }
        ]
      }
    }
  }
}
```

::: tip

Ts.ED support also Generics Deep object style!

```typescript
class FindQuery {
  @Property()
  tableColumnNameA?: number;

  @Property()
  tableColumnNameB?: number;
}

@Generics("T")
class PaginationQuery<T> {
  @Minimum(0)
  @Default(0)
  offset?: number;

  @Minimum(1)
  @Maximum(1000)
  @Default(50)
  limit?: number;

  @Property("T")
  where?: T;
}

@Path("/test")
class TestDeepObjectCtrl {
  @OperationPath("GET", "/")
  async get(@QueryParams() @GenericOf(FindQuery) q: PaginationQuery<FindQuery>) {}
}
```

:::

::: warning
This feature is only available for OpenAPI 3.
:::

## Annotations

JSON Schema includes a few keywords and Ts.ED provide also theses corresponding decorators like @@Title@@,
@@Description@@, @@Default@@, @@Examples@@ that aren’t strictly used for validation, but are used to describe parts of a
schema.

None of these `annotation` keywords are required, but they are encouraged for good practice, and can make your
schema `self-documenting`.

<Tabs class="-code">
  <Tab label="Model">

<<< @/docs/snippets/model/annotations.ts

  </Tab>
  <Tab label="Json schema">

<<< @/docs/snippets/model/annotations.json

  </Tab>
</Tabs>

## Alias

@@Name@@ decorator lets you to rename the exposed property in your json schema.

For example mongo db uses the `_id` property. In order not to give any indication to our consumer about the nature of
the database, it's better to rename the property to `id`.

<<< @/docs/snippets/model/name.ts

## Set Schema

If Ts.ED doesn't provide the expected decorator to describe your json schema, you can use the @@Schema@@ decorator
from `@tsed/common` to set a custom schema.

### Using JsonSchemaObject

You can declare schema by using the @@JsonSchemaObject@@ interface:

<<< @/docs/snippets/model/raw-schema-controller.ts

### Using functions <Badge text="6.14.0+"/>

It's also possible to write a valid JsonSchema by using the functional approach (Joi like):

<<< @/docs/snippets/model/functional-schema-controller.ts

Here is the list of available functions:

<ApiList query="status.includes('schemaFunctional')" />

## Get Json schema

In some cases, it may be useful to retrieve the JSON Schema from a Model to use with another library. This is possible
by using @@getJsonSchema@@. Here is a small example:

<Tabs class="-code">
  <Tab label="Model">

<<< @/docs/snippets/model/jsonschema.ts

  </Tab>
  <Tab label="Json schema">

<<< @/docs/snippets/model/jsonschema.json

  </Tab>
</Tabs>

## Expose a JsonSchema

You can create a controller, or an endpoint to expose a specific schema with the custom keys. This can allow your
consumers to retrieve a validation template so that they can use it to validate a form.

```typescript
import {Controller, Get} from "@tsed/common";
import {getJsonSchema} from "@tsed/schema";
import {Product} from "../models/Product";

@Controller("/products")
export class ProductsCtrl {
  @Get("/.schema")
  get(@QueryParams('customKeys') customKeys: boolean, @QueryParams('groups') groups: string[]) {
    return getJsonSchema(Product, {customKeys, groups});
  }
}
```

## Get OpenSpec

In some cases, it may be useful to retrieve the OpenSpec from a Controller to generate the Swagger OpenSpec. This is
possible by using @@getSpec@@. Here is a small example:

<Tabs class="-code">
  <Tab label="MyController">

<<< @/docs/snippets/model/get-spec-generics-controller1.ts

  </Tab>
  <Tab label="OpenSpec">

<<< @/docs/snippets/model/generics-controller1-os3.json

  </Tab>
</Tabs>

## Decorators

<ApiList query="status.includes('decorator') && status.includes('schema')" />
