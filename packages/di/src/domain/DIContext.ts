import type {Env} from "@tsed/core";
import {InjectorService} from "../services/InjectorService";
import {ContextLogger, ContextLoggerOptions} from "./ContextLogger";
import {LocalsContainer} from "./LocalsContainer";
import {runInContext} from "../utils/runInContext";

export interface ContextMethods extends Map<any, any> {
  readonly id: string;
  readonly logger: ContextLogger;
  readonly injector: InjectorService;
  readonly container: LocalsContainer;
  readonly env: Env;

  destroy(): any;
}

export interface DIContextOptions extends Omit<ContextLoggerOptions, "dateStart"> {
  id: string;
  logger: any;
  injector?: InjectorService;
}

export class DIContext extends Map<any, any> implements ContextMethods {
  [x: string]: any;
  /**
   * Request id generated by @@contextMiddleware@@.
   *
   * ::: tip
   * By default Ts.ED generate uuid like that `uuidv4().replace(/-/gi, ""))`.
   * Dash are removed to simplify tracking logs in Kibana
   * :::
   *
   * ::: tip
   * Request id can by customized by changing the server configuration.
   *
   * ```typescript
   * @Configuration({
   *   logger: {
   *     reqIdBuilder: createUniqId // give your own id generator function
   *   }
   * })
   * class Server {
   *
   * }
   * ```
   * :::
   *
   */
  readonly id: string;
  /**
   * Date when request have been handled by the server. @@RequestLogger@@ use this date to log request duration.
   */
  readonly dateStart: Date = new Date();
  /**
   * The request container used by the Ts.ED DI. It contain all services annotated with `@Scope(ProviderScope.REQUEST)`
   */
  public container = new LocalsContainer<any>();
  /**
   * Logger attached to the context request.
   */
  readonly logger: ContextLogger;
  /**
   *
   */
  readonly injector: InjectorService;

  constructor({id, injector, logger, ignoreLog, ...options}: DIContextOptions) {
    super();
    this.id = id;

    injector && (this.injector = injector);

    this.logger = new ContextLogger(logger, {
      ...options,
      dateStart: this.dateStart,
      id,
      ignoreLog
    });
  }

  get env() {
    return this.injector.settings.get("env");
  }

  async destroy() {
    await this.container.destroy();
    this.logger.destroy();

    // @ts-ignore
    delete this.container;
  }

  async emit(eventName: string, ...args: any[]) {
    return this.injector?.emit(eventName, ...args);
  }

  async runInContext(next: Function) {
    return runInContext(this, async () => {
      next = (await this.injector?.alterAsync("$alterRunInContext", next, this)) || next;
      return next();
    });
  }
}

export type BaseContext = DIContext & TsED.Context;
