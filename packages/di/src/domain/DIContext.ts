import type {Env} from "@tsed/core";
import {InjectorService} from "../services/InjectorService";
import {runInContext} from "../utils/runInContext";
import {ContextLogger, ContextLoggerOptions} from "./ContextLogger";
import {LocalsContainer} from "./LocalsContainer";

export interface ContextMethods extends Map<any, any> {
  readonly id: string;
  readonly logger: ContextLogger;
  readonly injector: InjectorService;
  readonly container: LocalsContainer;
  readonly env: Env;

  destroy(): any;
}

export interface DIContextOptions extends Omit<ContextLoggerOptions, "dateStart"> {
  id: string;
  injector: InjectorService;
  logger: any;
}

export class DIContext extends Map<any, any> implements ContextMethods {
  [x: string]: any;

  /**
   * The request container used by the Ts.ED DI. It contain all services annotated with `@Scope(ProviderScope.REQUEST)`
   */
  public container = new LocalsContainer<any>();
  /**
   * Logger attached to the context request.
   */
  readonly logger: ContextLogger;

  constructor(readonly options: DIContextOptions) {
    super();
    this.opts = options;
    this.logger = new ContextLogger(this);
  }

  /**
   * Request id generated by @@contextMiddleware@@.
   *
   * ::: tip
   * By default Ts.ED generate uuid like that `uuidv4().replace(/-/gi, ""))`.
   * Dash are removed to simplify tracking logs in Kibana
   * :::
   *
   * ::: tip
   * Request id can by customized by changing the server configuration.
   *
   * ```typescript
   * @Configuration({
   *   logger: {
   *     reqIdBuilder: createUniqId // give your own id generator function
   *   }
   * })
   * class Server {
   *
   * }
   * ```
   * :::
   *
   */
  get id() {
    return this.opts.id;
  }

  get dateStart() {
    return this.logger.dateStart;
  }

  get injector(): InjectorService {
    return this.opts.injector!;
  }

  get env() {
    return this.injector.settings.get("env");
  }

  async destroy() {
    await this.container.destroy();
    this.logger.destroy();
    this.opts = null as any;
    this.container = null as any;
  }

  async emit(eventName: string, ...args: any[]) {
    return this.injector?.emit(eventName, ...args);
  }

  async runInContext(next: Function) {
    next = (await this.injector?.alterAsync("$alterRunInContext", next, this)) || next;

    return runInContext(this, next);
  }
}

export type BaseContext = DIContext & TsED.Context;
